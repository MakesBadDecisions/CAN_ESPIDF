// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 8.3.11
// Project name: 4.3Gauge

#include "ui.h"
#include "comm_link.h"
#include "display_driver.h"
#include "gauge_engine.h"
#include "data_logger.h"
#include "pid_types.h"
#include "imu_display.h"
#include "esp_log.h"
#include "ui_Screen1.h"
#include "ui_Screen2.h"
#include <stdio.h>
#include <string.h>

static const char *TAG = "ui_events";

// Forward declarations for static helpers
static void settings_screen_deferred_init(lv_timer_t *timer);
static void settings_screen_init_values(void);
static void on_brightness_changed(lv_event_t *e);

// ============================================================================
// Table-driven gauge widget mapping
//
// Each entry links a gauge_engine slot index to its LVGL widgets.
// To add more gauges: add rows here + create widgets in SquareLine.
// ============================================================================

typedef struct {
    lv_obj_t **gauge_panel;     // Parent panel (for IMU display attachment)
    lv_obj_t **pid_dropdown;    // PID selector
    lv_obj_t **unit_dropdown;   // Unit selector
    lv_obj_t **value_label;     // Numeric value text
} gauge_widget_t;

// Screen1 has 4 gauges -- just extend this array for more
static const gauge_widget_t s_gauge_widgets[] = {
    { &ui_gauge1, &ui_piddropdown1, &ui_unitdropdown1, &ui_gaugeText1 },
    { &ui_gauge2, &ui_piddropdown2, &ui_unitdropdown2, &ui_gaugeText2 },
    { &ui_gauge3, &ui_piddropdown3, &ui_unitdropdown3, &ui_gaugeText3 },
    { &ui_gauge4, &ui_piddropdown4, &ui_unitdropdown4, &ui_gaugeText4 },
};

#define NUM_GAUGE_WIDGETS (sizeof(s_gauge_widgets) / sizeof(s_gauge_widgets[0]))

// ============================================================================
// Timers
// ============================================================================

static lv_timer_t *s_gauge_timer = NULL;

// Scan timeout (10 seconds)
#define SCAN_TIMEOUT_MS  10000
static lv_timer_t *s_scan_timer = NULL;

// Track whether events have been wired (once per dropdown)
static bool s_events_registered = false;

// ============================================================================
// Connection Status Label (ui_statusLabel1 from SquareLine Studio)
// ============================================================================

static comm_link_state_t s_last_link_state = COMM_LINK_DISCONNECTED;
static uint8_t s_last_can_status = 0;
static lv_timer_t *s_status_timer = NULL;

/** Update the status label to show both UART link and CAN bus state */
static void update_status_label(void)
{
    if (!ui_statusLabel1) return;

    comm_link_state_t link = comm_link_get_state();
    uint8_t can = comm_link_get_can_status();

    if (link == s_last_link_state && can == s_last_can_status) return;
    s_last_link_state = link;
    s_last_can_status = can;

    // Build UART portion
    const char *uart_str;
    switch (link) {
        case COMM_LINK_CONNECTED:    uart_str = "OK";    break;
        case COMM_LINK_ERROR:        uart_str = "ERR";   break;
        default:                     uart_str = "OFF";   break;
    }

    // Build CAN portion
    const char *can_str;
    switch (can) {
        case 1:  can_str = "OK";  break;
        case 2:  can_str = "ERR"; break;
        default: can_str = "OFF"; break;
    }

    static char status_buf[32];
    snprintf(status_buf, sizeof(status_buf), "UART: %s | CAN: %s", uart_str, can_str);
    lv_label_set_text(ui_statusLabel1, status_buf);

    // Color: green only if both OK, red if any error, yellow if mixed
    if (link == COMM_LINK_CONNECTED && can == 1) {
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0x44FF44), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else if (link == COMM_LINK_ERROR || can == 2) {
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0xFF4444), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0xFFCC00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

static void status_timer_cb(lv_timer_t *timer)
{
    (void)timer;
    update_status_label();
}

// ============================================================================
// Scan Timeout Timer
// ============================================================================

static void scan_timeout_cb(lv_timer_t *timer)
{
    (void)timer;
    s_scan_timer = NULL;

    if (comm_link_get_scan_status() != SCAN_STATUS_COMPLETE) {
        ESP_LOGW(TAG, "Scan timed out after %d ms", SCAN_TIMEOUT_MS);
        lv_label_set_text(ui_Label1, "Connect");
        lv_label_set_text(ui_vehicleInfoLabel1, "Scan timeout");
    }
}

// ============================================================================
// Gauge Update Timer (10 Hz, LVGL task context)
// ============================================================================

static uint32_t s_stale_check_tick = 0;

static void gauge_update_cb(lv_timer_t *timer)
{
    (void)timer;

    // Skip update if no new data arrived (check stale every 1s regardless)
    bool new_data = gauge_engine_has_new_data();
    uint32_t now = lv_tick_get();
    bool stale_check = (now - s_stale_check_tick) >= 1000;

    if (!new_data && !stale_check) return;
    if (stale_check) s_stale_check_tick = now;

    // Let gauge_engine fetch values + convert + format strings
    gauge_engine_update();

    // Log a data row to SD card (if logging active)
    if (new_data) {
        logger_log_row();
    }

    // Push formatted strings to LVGL labels
    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        if (!g || g->pid_id == 0xFFFF) continue;

        // Virtual IMU — imu_display has its own timer, skip label update
        if (GAUGE_IS_VIRTUAL(g->pid_id)) continue;

        lv_obj_t *label = *(s_gauge_widgets[i].value_label);
        if (label) {
            lv_label_set_text(label, g->value_str);
            // Dim text when data is stale
            if (g->stale) {
                lv_obj_set_style_text_opa(label, LV_OPA_40, LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_obj_set_style_text_opa(label, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
            }
        }
    }
}

// ============================================================================
// PID Dropdown Changed (any gauge)
// ============================================================================

static void on_pid_changed(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target(e);

    // Find which gauge slot this dropdown belongs to
    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        if (*(s_gauge_widgets[i].pid_dropdown) != dropdown) continue;

        uint16_t sel = lv_dropdown_get_selected(dropdown);

        // Check what was previously in this slot (for IMU detach)
        const gauge_slot_t *prev = gauge_engine_get_slot(i);
        bool was_imu = prev && prev->pid_id == VPID_IMU;

        gauge_engine_set_pid(i, sel);

        // Check if the new selection is IMU
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        bool is_imu = g && g->pid_id == VPID_IMU;

        // --- IMU attach / detach logic ---
        if (was_imu && !is_imu) {
            // Switching away from IMU — detach bubble, show value label
            imu_display_detach();
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_obj_clear_flag(label, LV_OBJ_FLAG_HIDDEN);
        }

        if (is_imu && !was_imu) {
            // Switching to IMU — enforce uniqueness (detach from other slot)
            for (int j = 0; j < (int)NUM_GAUGE_WIDGETS; j++) {
                if (j == i) continue;
                const gauge_slot_t *other = gauge_engine_get_slot(j);
                if (other && other->pid_id == VPID_IMU) {
                    gauge_engine_clear_slot(j);
                    lv_obj_t *other_label = *(s_gauge_widgets[j].value_label);
                    if (other_label) {
                        lv_obj_clear_flag(other_label, LV_OBJ_FLAG_HIDDEN);
                        lv_label_set_text(other_label, "---");
                    }
                    // Reset that slot's PID dropdown to "none" (first entry)
                    lv_obj_t *other_dd = *(s_gauge_widgets[j].pid_dropdown);
                    if (other_dd) lv_dropdown_set_selected(other_dd, 0);
                }
            }

            // Hide value label, attach IMU display to this gauge panel
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_obj_add_flag(label, LV_OBJ_FLAG_HIDDEN);

            lv_obj_t *panel = *(s_gauge_widgets[i].gauge_panel);
            imu_display_attach(panel);
        }

        // Refresh unit dropdown for this gauge
        static char unit_opts[GAUGE_UNIT_OPTS_LEN];
        gauge_engine_get_unit_options(i, unit_opts, sizeof(unit_opts));
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
        if (unit_dd) {
            lv_dropdown_set_options(unit_dd, unit_opts);
            lv_dropdown_set_selected(unit_dd, 0);
        }

        // Reset value display (for non-IMU slots)
        if (!is_imu) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        ESP_LOGI(TAG, "Gauge %d -> PID 0x%04X%s", i,
                 g ? g->pid_id : 0xFFFF, is_imu ? " (IMU)" : "");
        return;
    }
}

// ============================================================================
// Unit Dropdown Changed (any gauge)
// ============================================================================

static void on_unit_changed(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target(e);

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        if (*(s_gauge_widgets[i].unit_dropdown) != dropdown) continue;

        uint16_t sel = lv_dropdown_get_selected(dropdown);
        gauge_engine_set_unit(i, sel);

        // For IMU, also notify imu_display of mode change
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        if (g && g->pid_id == VPID_IMU) {
            imu_display_set_mode((imu_display_mode_t)sel);
        } else if (g && g->value_valid) {
            // Immediately update the label if we have a value
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, g->value_str);
        }

        ESP_LOGI(TAG, "Gauge %d unit index -> %d", i, sel);
        return;
    }
}

// ============================================================================
// Register dropdown events for all gauge widgets (once)
// ============================================================================

static void register_gauge_events(void)
{
    if (s_events_registered) return;

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        lv_obj_t *pid_dd  = *(s_gauge_widgets[i].pid_dropdown);
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);

        if (pid_dd)  lv_obj_add_event_cb(pid_dd,  on_pid_changed,  LV_EVENT_VALUE_CHANGED, NULL);
        if (unit_dd) lv_obj_add_event_cb(unit_dd, on_unit_changed, LV_EVENT_VALUE_CHANGED, NULL);
    }

    s_events_registered = true;
    ESP_LOGI(TAG, "Registered events for %d gauge widgets", (int)NUM_GAUGE_WIDGETS);
}

// ============================================================================
// Populate all PID dropdowns with scan results
// ============================================================================

static void populate_all_pid_dropdowns(void)
{
    static char pid_opts[2048];
    int count = gauge_engine_build_pid_options(pid_opts, sizeof(pid_opts));
    if (count == 0) return;

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        lv_obj_t *dd = *(s_gauge_widgets[i].pid_dropdown);
        if (dd) {
            lv_dropdown_set_options(dd, pid_opts);
        }
    }

    ESP_LOGI(TAG, "Populated %d gauge dropdowns with %d PIDs",
             (int)NUM_GAUGE_WIDGETS, count);
}

// ============================================================================
// Scan Complete Callback (called from rx_task, must lock LVGL)
// ============================================================================

static void on_scan_complete(scan_status_t status, const comm_vehicle_info_t *info)
{
    if (!display_lock(200)) {
        ESP_LOGW(TAG, "Could not acquire display lock for scan callback");
        return;
    }

    // Cancel scan timeout timer
    if (s_scan_timer) {
        lv_timer_del(s_scan_timer);
        s_scan_timer = NULL;
    }

    if (status == SCAN_STATUS_COMPLETE && info) {
        ESP_LOGI(TAG, "Scan complete! VIN: %.17s", info->vin);

        // Show VIN
        static char vin_text[32];
        snprintf(vin_text, sizeof(vin_text), "VIN: %.17s", info->vin);
        lv_label_set_text(ui_vehicleInfoLabel1, vin_text);
        lv_label_set_text(ui_Label1, "Scan");

        // Populate all gauge PID dropdowns
        populate_all_pid_dropdowns();

        // Wire up dropdown events (idempotent)
        register_gauge_events();

        // Restore saved gauge config (PID + unit per slot) from NVS
        int restored = gauge_engine_load_config();
        if (restored > 0) {
            // Sync dropdown selections to match restored slots
            int meta_count = comm_link_get_pid_meta_count();
            for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
                const gauge_slot_t *g = gauge_engine_get_slot(i);
                if (!g || g->pid_id == 0xFFFF) continue;

                // Handle virtual IMU PID restoration
                if (g->pid_id == VPID_IMU) {
                    // Set PID dropdown to IMU entry (index = meta_count)
                    lv_obj_t *pid_dd = *(s_gauge_widgets[i].pid_dropdown);
                    if (pid_dd) lv_dropdown_set_selected(pid_dd, meta_count);

                    // Set unit dropdown (G-Load / Tilt)
                    static char imu_unit_opts[GAUGE_UNIT_OPTS_LEN];
                    gauge_engine_get_unit_options(i, imu_unit_opts, sizeof(imu_unit_opts));
                    lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
                    if (unit_dd) {
                        lv_dropdown_set_options(unit_dd, imu_unit_opts);
                        lv_dropdown_set_selected(unit_dd, (int)g->display_unit);
                    }

                    // Hide value label and attach IMU display
                    lv_obj_t *label = *(s_gauge_widgets[i].value_label);
                    if (label) lv_obj_add_flag(label, LV_OBJ_FLAG_HIDDEN);

                    lv_obj_t *panel = *(s_gauge_widgets[i].gauge_panel);
                    imu_display_attach(panel);
                    imu_display_set_mode((imu_display_mode_t)g->display_unit);

                    ESP_LOGI(TAG, "Restored IMU in gauge slot %d", i);
                    continue;
                }

                // Find metadata index for this PID to set dropdown selection
                for (int m = 0; m < meta_count; m++) {
                    if (comm_link_get_meta_pid_id(m) == g->pid_id) {
                        lv_obj_t *pid_dd = *(s_gauge_widgets[i].pid_dropdown);
                        if (pid_dd) lv_dropdown_set_selected(pid_dd, m);
                        break;
                    }
                }

                // Refresh unit dropdown and select saved unit
                static char unit_opts[GAUGE_UNIT_OPTS_LEN];
                int n_units = gauge_engine_get_unit_options(i, unit_opts, sizeof(unit_opts));
                lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
                if (unit_dd && n_units > 0) {
                    lv_dropdown_set_options(unit_dd, unit_opts);
                    // Find which index corresponds to current display_unit
                    if (g->display_unit != g->base_unit) {
                        pid_unit_t alts[4];
                        int n_alts = pid_unit_get_alts(g->base_unit, alts, 4);
                        for (int u = 0; u < n_alts; u++) {
                            if (alts[u] == g->display_unit) {
                                lv_dropdown_set_selected(unit_dd, u + 1);
                                break;
                            }
                        }
                    }
                }
            }
            ESP_LOGI(TAG, "Restored %d gauge slot(s) from NVS", restored);
        } else {
            // No saved config -- auto-select first PID on gauge 0 as default
            gauge_engine_set_pid(0, 0);
            lv_obj_t *pid_dd = *(s_gauge_widgets[0].pid_dropdown);
            if (pid_dd) lv_dropdown_set_selected(pid_dd, 0);

            static char def_unit_opts[GAUGE_UNIT_OPTS_LEN];
            gauge_engine_get_unit_options(0, def_unit_opts, sizeof(def_unit_opts));
            lv_obj_t *unit_dd = *(s_gauge_widgets[0].unit_dropdown);
            if (unit_dd) {
                lv_dropdown_set_options(unit_dd, def_unit_opts);
                lv_dropdown_set_selected(unit_dd, 0);
            }
            ESP_LOGI(TAG, "No saved config, defaulted gauge 0 to first PID");
        }

    } else {
        ESP_LOGW(TAG, "Scan failed with status %d", status);
        lv_label_set_text(ui_Label1, "Connect");
    }

    display_unlock();
}

// ============================================================================
// Connect Button - Scan Vehicle
// ============================================================================

void connectCAN(lv_event_t * e)
{
    (void)e;

    if (comm_link_get_scan_status() == SCAN_STATUS_IN_PROGRESS) {
        ESP_LOGI(TAG, "Scan already in progress...");
        return;
    }

    ESP_LOGI(TAG, "Requesting vehicle scan...");
    lv_label_set_text(ui_Label1, "Scanning...");

    // Start scan timeout timer (one-shot)
    if (s_scan_timer) {
        lv_timer_del(s_scan_timer);
    }
    s_scan_timer = lv_timer_create(scan_timeout_cb, SCAN_TIMEOUT_MS, NULL);
    lv_timer_set_repeat_count(s_scan_timer, 1);

    esp_err_t err = comm_link_request_scan(on_scan_complete);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to request scan: %s", esp_err_to_name(err));
        lv_label_set_text(ui_Label1, "Connect");
    }
}

// ============================================================================
// Poll Button - Start/Stop Polling All Assigned Gauges
// ============================================================================

void pollCAN(lv_event_t * e)
{
    (void)e;

    if (gauge_engine_is_polling()) {
        // Stop logging first, then stop polling
        if (logger_get_state() == LOGGER_STATE_LOGGING) {
            logger_stop();
            ESP_LOGI(TAG, "Data logging stopped");
        }
        gauge_engine_stop_polling();
        lv_label_set_text(ui_Label2, "Poll");

        // Clear all gauge displays
        for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        if (s_gauge_timer) {
            lv_timer_del(s_gauge_timer);
            s_gauge_timer = NULL;
        }

        ESP_LOGI(TAG, "Polling stopped");
        return;
    }

    // Must scan first
    if (comm_link_get_pid_meta_count() == 0) {
        ESP_LOGW(TAG, "No PID metadata - scan vehicle first");
        return;
    }

    // Start polling all assigned PIDs
    esp_err_t err = gauge_engine_start_polling(10);
    if (err != ESP_OK) {
        ESP_LOGW(TAG, "No PIDs assigned to any gauge");
        return;
    }

    // Start LVGL update timer (100ms = 10 Hz)
    if (!s_gauge_timer) {
        s_gauge_timer = lv_timer_create(gauge_update_cb, 100, NULL);
    }

    lv_label_set_text(ui_Label2, "Stop");

    int n = gauge_engine_get_active_pid_count();
    ESP_LOGI(TAG, "Polling %d unique PIDs @ 10 Hz", n);

    // Auto-start data logger if SD card is ready
    if (logger_is_sd_mounted()) {
        // Build list of polled PIDs from gauge slots
        uint16_t log_pids[GAUGE_MAX_SLOTS];
        int log_count = 0;
        for (int i = 0; i < GAUGE_MAX_SLOTS; i++) {
            const gauge_slot_t *g = gauge_engine_get_slot(i);
            if (!g || g->pid_id == 0xFFFF) continue;
            if (GAUGE_IS_VIRTUAL(g->pid_id)) continue;  // Skip virtual PIDs
            // Deduplicate
            bool dup = false;
            for (int j = 0; j < log_count; j++) {
                if (log_pids[j] == g->pid_id) { dup = true; break; }
            }
            if (!dup) log_pids[log_count++] = g->pid_id;
        }
        if (log_count > 0) {
            // Get VIN if available
            comm_vehicle_info_t vinfo;
            const char *vin = NULL;
            if (comm_link_get_vehicle_info(&vinfo)) {
                vin = vinfo.vin;
            }
            esp_err_t log_ret = logger_start(log_pids, log_count, vin);
            if (log_ret == ESP_OK) {
                ESP_LOGI(TAG, "Data logging started (%d channels)", log_count);
            } else {
                ESP_LOGW(TAG, "Data logging failed to start: %s", esp_err_to_name(log_ret));
            }
        }
    }
}

// ============================================================================
// Post-Init (called from main.c after ui_init + gauge_engine_init)
// Must be called with display lock held.
// ============================================================================

void ui_events_post_init(void)
{
    // Set initial state on SquareLine-created label
    if (ui_statusLabel1) {
        lv_label_set_text(ui_statusLabel1, "UART: OFF | CAN: OFF");
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0xFFCC00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    s_last_link_state = COMM_LINK_DISCONNECTED;
    s_last_can_status = 0;
    s_status_timer = lv_timer_create(status_timer_cb, 500, NULL);

    // IMU display initialized when user selects "IMU" in PID dropdown
    // (no longer tied to a fixed gyroPanel widget)

    // Show saved VIN from NVS (if available from previous session)
    comm_vehicle_info_t saved_info;
    if (comm_link_get_vehicle_info(&saved_info)) {
        static char vin_text[32];
        snprintf(vin_text, sizeof(vin_text), "VIN: %.17s", saved_info.vin);
        lv_label_set_text(ui_vehicleInfoLabel1, vin_text);
        ESP_LOGI(TAG, "Showing saved VIN: %.17s", saved_info.vin);
    }

    ESP_LOGI(TAG, "Status label and timer started");
}

// ============================================================================
// Settings Button — navigate to Screen2 (auto-stops polling)
// ============================================================================

void settingsButton(lv_event_t * e)
{
    (void)e;

    // Auto-stop polling when entering settings
    if (gauge_engine_is_polling()) {
        ESP_LOGI(TAG, "Stopping polling before entering settings...");

        // Stop logger first
        if (logger_get_state() == LOGGER_STATE_LOGGING) {
            logger_stop();
            ESP_LOGI(TAG, "Data logging stopped for settings");
        }

        gauge_engine_stop_polling();

        // Clear gauge displays
        for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        if (s_gauge_timer) {
            lv_timer_del(s_gauge_timer);
            s_gauge_timer = NULL;
        }

        // Update poll button text
        lv_label_set_text(ui_Label2, "Poll");
        ESP_LOGI(TAG, "Polling stopped");
    }

    // NOTE: SquareLine calls _ui_screen_change() AFTER this function returns,
    // which destroys and recreates Screen2. We must defer widget initialization
    // until after the screen transition completes.
    lv_timer_t *t = lv_timer_create(settings_screen_deferred_init, 200, NULL);
    lv_timer_set_repeat_count(t, 1);
}

// ============================================================================
// Settings Screen — deferred init (runs after screen transition completes)
// ============================================================================

static void settings_screen_deferred_init(lv_timer_t *timer)
{
    (void)timer;
    settings_screen_init_values();
}

static void settings_screen_init_values(void)
{
    // Set brightness slider to current value
    if (ui_brightnessSlider) {
        uint8_t bl = display_get_brightness();
        lv_slider_set_value(ui_brightnessSlider, bl, LV_ANIM_OFF);

        // Update label to match
        if (ui_brightnessLabel) {
            static char bl_text[8];
            snprintf(bl_text, sizeof(bl_text), "%d", bl);
            lv_label_set_text(ui_brightnessLabel, bl_text);
        }

        // Register brightness callback on the newly-created slider
        // (must re-register every time — Screen2 is destroyed/recreated on each visit)
        lv_obj_add_event_cb(ui_brightnessSlider, on_brightness_changed,
                            LV_EVENT_VALUE_CHANGED, NULL);
    }

    ESP_LOGI(TAG, "Settings screen values initialized (brightness: %d%%)",
             display_get_brightness());
}

// ============================================================================
// Brightness Slider — apply brightness on value change
// ============================================================================

static void on_brightness_changed(lv_event_t *e)
{
    lv_obj_t *slider = lv_event_get_target(e);
    int32_t val = lv_slider_get_value(slider);
    if (val < 0) val = 0;
    if (val > 100) val = 100;

    display_set_brightness((uint8_t)val);

    // Update label
    if (ui_brightnessLabel) {
        static char bl_text[8];
        snprintf(bl_text, sizeof(bl_text), "%d", (int)val);
        lv_label_set_text(ui_brightnessLabel, bl_text);
    }
}

// ============================================================================
// WiFi AP Start Button — start WiFi AP and show QR code
// ============================================================================

void wifiAPstart(lv_event_t * e)
{
    (void)e;
    ESP_LOGI(TAG, "WiFi AP start requested (not yet implemented)");
    // TODO: wifi_manager_start() + QR code in ui_systemPanel
}
