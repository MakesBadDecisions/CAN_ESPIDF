// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 8.3.11
// Project name: 4.3Gauge

#include "ui.h"
#include "comm_link.h"
#include "display_driver.h"
#include "gauge_engine.h"
#include "esp_log.h"
#include "screens/ui_Screen1.h"
#include <stdio.h>
#include <string.h>

static const char *TAG = "ui_events";

// ============================================================================
// Table-driven gauge widget mapping
//
// Each entry links a gauge_engine slot index to its LVGL widgets.
// To add more gauges: add rows here + create widgets in SquareLine.
// ============================================================================

typedef struct {
    lv_obj_t **pid_dropdown;    // PID selector
    lv_obj_t **unit_dropdown;   // Unit selector
    lv_obj_t **value_label;     // Numeric value text
} gauge_widget_t;

// Screen1 has 4 gauges -- just extend this array for more
static const gauge_widget_t s_gauge_widgets[] = {
    { &ui_piddropdown1, &ui_unitdropdown1, &ui_gaugeText1 },
    { &ui_piddropdown2, &ui_unitdropdown2, &ui_gaugeText2 },
    { &ui_piddropdown3, &ui_unitdropdown3, &ui_gaugeText3 },
    { &ui_piddropdown4, &ui_unitdropdown4, &ui_gaugeText4 },
};

#define NUM_GAUGE_WIDGETS (sizeof(s_gauge_widgets) / sizeof(s_gauge_widgets[0]))

// ============================================================================
// Timers
// ============================================================================

static lv_timer_t *s_gauge_timer = NULL;

// Scan timeout (10 seconds)
#define SCAN_TIMEOUT_MS  10000
static lv_timer_t *s_scan_timer = NULL;

// Track whether events have been wired (once per dropdown)
static bool s_events_registered = false;

// ============================================================================
// Scan Timeout Timer
// ============================================================================

static void scan_timeout_cb(lv_timer_t *timer)
{
    (void)timer;
    s_scan_timer = NULL;

    if (comm_link_get_scan_status() != SCAN_STATUS_COMPLETE) {
        ESP_LOGW(TAG, "Scan timed out after %d ms", SCAN_TIMEOUT_MS);
        lv_label_set_text(ui_Label1, "Connect");
        lv_label_set_text(ui_vehicleInfoLabel1, "Scan timeout");
    }
}

// ============================================================================
// Gauge Update Timer (10 Hz, LVGL task context)
// ============================================================================

static void gauge_update_cb(lv_timer_t *timer)
{
    (void)timer;

    // Let gauge_engine fetch values + convert + format strings
    gauge_engine_update();

    // Push formatted strings to LVGL labels
    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        if (!g || g->pid_id == 0xFFFF) continue;

        lv_obj_t *label = *(s_gauge_widgets[i].value_label);
        if (label) {
            lv_label_set_text(label, g->value_str);
        }
    }
}

// ============================================================================
// PID Dropdown Changed (any gauge)
// ============================================================================

static void on_pid_changed(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target(e);

    // Find which gauge slot this dropdown belongs to
    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        if (*(s_gauge_widgets[i].pid_dropdown) != dropdown) continue;

        uint16_t sel = lv_dropdown_get_selected(dropdown);
        gauge_engine_set_pid(i, sel);

        // Refresh unit dropdown for this gauge
        static char unit_opts[GAUGE_UNIT_OPTS_LEN];
        gauge_engine_get_unit_options(i, unit_opts, sizeof(unit_opts));
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
        if (unit_dd) {
            lv_dropdown_set_options(unit_dd, unit_opts);
            lv_dropdown_set_selected(unit_dd, 0);
        }

        // Reset value display
        lv_obj_t *label = *(s_gauge_widgets[i].value_label);
        if (label) lv_label_set_text(label, "---");

        const gauge_slot_t *g = gauge_engine_get_slot(i);
        ESP_LOGI(TAG, "Gauge %d -> PID 0x%04X", i, g ? g->pid_id : 0xFFFF);
        return;
    }
}

// ============================================================================
// Unit Dropdown Changed (any gauge)
// ============================================================================

static void on_unit_changed(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target(e);

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        if (*(s_gauge_widgets[i].unit_dropdown) != dropdown) continue;

        uint16_t sel = lv_dropdown_get_selected(dropdown);
        gauge_engine_set_unit(i, sel);

        // Immediately update the label if we have a value
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        if (g && g->value_valid) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, g->value_str);
        }

        ESP_LOGI(TAG, "Gauge %d unit index -> %d", i, sel);
        return;
    }
}

// ============================================================================
// Register dropdown events for all gauge widgets (once)
// ============================================================================

static void register_gauge_events(void)
{
    if (s_events_registered) return;

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        lv_obj_t *pid_dd  = *(s_gauge_widgets[i].pid_dropdown);
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);

        if (pid_dd)  lv_obj_add_event_cb(pid_dd,  on_pid_changed,  LV_EVENT_VALUE_CHANGED, NULL);
        if (unit_dd) lv_obj_add_event_cb(unit_dd, on_unit_changed, LV_EVENT_VALUE_CHANGED, NULL);
    }

    s_events_registered = true;
    ESP_LOGI(TAG, "Registered events for %d gauge widgets", (int)NUM_GAUGE_WIDGETS);
}

// ============================================================================
// Populate all PID dropdowns with scan results
// ============================================================================

static void populate_all_pid_dropdowns(void)
{
    static char pid_opts[2048];
    int count = gauge_engine_build_pid_options(pid_opts, sizeof(pid_opts));
    if (count == 0) return;

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        lv_obj_t *dd = *(s_gauge_widgets[i].pid_dropdown);
        if (dd) {
            lv_dropdown_set_options(dd, pid_opts);
        }
    }

    // Auto-select first PID and populate unit dropdown for gauge 0
    gauge_engine_set_pid(0, 0);

    static char unit_opts[GAUGE_UNIT_OPTS_LEN];
    gauge_engine_get_unit_options(0, unit_opts, sizeof(unit_opts));
    lv_obj_t *unit_dd = *(s_gauge_widgets[0].unit_dropdown);
    if (unit_dd) {
        lv_dropdown_set_options(unit_dd, unit_opts);
        lv_dropdown_set_selected(unit_dd, 0);
    }

    ESP_LOGI(TAG, "Populated %d gauge dropdowns with %d PIDs",
             (int)NUM_GAUGE_WIDGETS, count);
}

// ============================================================================
// Scan Complete Callback (called from rx_task, must lock LVGL)
// ============================================================================

static void on_scan_complete(scan_status_t status, const comm_vehicle_info_t *info)
{
    if (!display_lock(200)) {
        ESP_LOGW(TAG, "Could not acquire display lock for scan callback");
        return;
    }

    // Cancel scan timeout timer
    if (s_scan_timer) {
        lv_timer_del(s_scan_timer);
        s_scan_timer = NULL;
    }

    if (status == SCAN_STATUS_COMPLETE && info) {
        ESP_LOGI(TAG, "Scan complete! VIN: %.17s", info->vin);

        // Show VIN
        static char vin_text[32];
        snprintf(vin_text, sizeof(vin_text), "VIN: %.17s", info->vin);
        lv_label_set_text(ui_vehicleInfoLabel1, vin_text);
        lv_label_set_text(ui_Label1, "Scan");

        // Populate all gauge PID dropdowns
        populate_all_pid_dropdowns();

        // Wire up dropdown events (idempotent)
        register_gauge_events();

    } else {
        ESP_LOGW(TAG, "Scan failed with status %d", status);
        lv_label_set_text(ui_Label1, "Connect");
    }

    display_unlock();
}

// ============================================================================
// Connect Button - Scan Vehicle
// ============================================================================

void connectCAN(lv_event_t * e)
{
    (void)e;

    if (comm_link_get_scan_status() == SCAN_STATUS_IN_PROGRESS) {
        ESP_LOGI(TAG, "Scan already in progress...");
        return;
    }

    ESP_LOGI(TAG, "Requesting vehicle scan...");
    lv_label_set_text(ui_Label1, "Scanning...");

    // Start scan timeout timer (one-shot)
    if (s_scan_timer) {
        lv_timer_del(s_scan_timer);
    }
    s_scan_timer = lv_timer_create(scan_timeout_cb, SCAN_TIMEOUT_MS, NULL);
    lv_timer_set_repeat_count(s_scan_timer, 1);

    esp_err_t err = comm_link_request_scan(on_scan_complete);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to request scan: %s", esp_err_to_name(err));
        lv_label_set_text(ui_Label1, "Connect");
    }
}

// ============================================================================
// Poll Button - Start/Stop Polling All Assigned Gauges
// ============================================================================

void pollCAN(lv_event_t * e)
{
    (void)e;

    if (gauge_engine_is_polling()) {
        // Stop
        gauge_engine_stop_polling();
        lv_label_set_text(ui_Label2, "Poll");

        // Clear all gauge displays
        for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        if (s_gauge_timer) {
            lv_timer_del(s_gauge_timer);
            s_gauge_timer = NULL;
        }

        ESP_LOGI(TAG, "Polling stopped");
        return;
    }

    // Must scan first
    if (comm_link_get_pid_meta_count() == 0) {
        ESP_LOGW(TAG, "No PID metadata - scan vehicle first");
        return;
    }

    // Start polling all assigned PIDs
    esp_err_t err = gauge_engine_start_polling(10);
    if (err != ESP_OK) {
        ESP_LOGW(TAG, "No PIDs assigned to any gauge");
        return;
    }

    // Start LVGL update timer (100ms = 10 Hz)
    if (!s_gauge_timer) {
        s_gauge_timer = lv_timer_create(gauge_update_cb, 100, NULL);
    }

    lv_label_set_text(ui_Label2, "Stop");

    int n = gauge_engine_get_active_pid_count();
    ESP_LOGI(TAG, "Polling %d unique PIDs @ 10 Hz", n);
}
