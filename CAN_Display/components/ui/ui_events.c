// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 8.3.11
// Project name: 4.3Gauge

#include "ui.h"
#include "comm_link.h"
#include "esp_log.h"
#include "screens/ui_Screen1.h"
#include <stdio.h>

static const char *TAG = "ui_events";

// PID name lookup (subset for testing)
static const char* get_pid_name(uint16_t pid) {
    switch (pid) {
        case 0x04: return "Engine Load";
        case 0x05: return "Coolant Temp";
        case 0x06: return "Short Fuel Trim B1";
        case 0x07: return "Long Fuel Trim B1";
        case 0x0B: return "Intake MAP";
        case 0x0C: return "Engine RPM";
        case 0x0D: return "Vehicle Speed";
        case 0x0E: return "Timing Advance";
        case 0x0F: return "Intake Air Temp";
        case 0x10: return "MAF Rate";
        case 0x11: return "Throttle Pos";
        case 0x1F: return "Run Time";
        case 0x21: return "Distance w/ MIL";
        case 0x2F: return "Fuel Level";
        case 0x31: return "Distance since CLR";
        case 0x33: return "Barometric";
        case 0x42: return "Control Module V";
        case 0x46: return "Ambient Air Temp";
        case 0x5C: return "Oil Temp";
        default:   return "Unknown PID";
    }
}

// Callback when scan completes
static void on_scan_complete(scan_status_t status, const comm_vehicle_info_t *info)
{
    if (status == SCAN_STATUS_COMPLETE && info) {
        ESP_LOGI(TAG, "Scan complete! VIN: %.17s", info->vin);
        
        // Update button text
        lv_label_set_text(ui_Label1, "Start");
        
        // Populate PID dropdown with supported PIDs
        uint16_t pids[MAX_SUPPORTED_PIDS];
        int count = comm_link_get_supported_pids(pids, MAX_SUPPORTED_PIDS);
        
        if (count > 0) {
            // Build dropdown options string
            static char dropdown_opts[1024];
            int pos = 0;
            for (int i = 0; i < count && pos < (int)sizeof(dropdown_opts) - 32; i++) {
                pos += snprintf(dropdown_opts + pos, sizeof(dropdown_opts) - pos,
                               "0x%02X %s\n", pids[i], get_pid_name(pids[i]));
            }
            if (pos > 0) dropdown_opts[pos - 1] = '\0';  // Remove trailing newline
            
            lv_dropdown_set_options(ui_piddropdown1, dropdown_opts);
            ESP_LOGI(TAG, "Populated dropdown with %d PIDs", count);
        }
    } else {
        ESP_LOGW(TAG, "Scan failed with status %d", status);
        lv_label_set_text(ui_Label1, "Connect");
    }
}

void connectCAN(lv_event_t * e)
{
    (void)e;  // Unused
    
    scan_status_t status = comm_link_get_scan_status();
    
    if (status == SCAN_STATUS_IN_PROGRESS) {
        ESP_LOGI(TAG, "Scan already in progress...");
        return;
    }
    
    // Check if we already have vehicle info
    comm_vehicle_info_t info;
    if (comm_link_get_vehicle_info(&info)) {
        // Already scanned - start polling selected PID
        uint16_t selected_idx = lv_dropdown_get_selected(ui_piddropdown1);
        uint16_t pids[MAX_SUPPORTED_PIDS];
        int count = comm_link_get_supported_pids(pids, MAX_SUPPORTED_PIDS);
        
        if (selected_idx < count) {
            uint16_t selected_pid = pids[selected_idx];
            ESP_LOGI(TAG, "Starting poll for PID 0x%02X", selected_pid);
            
            // Send poll list with single PID
            comm_link_set_poll_list(&selected_pid, 1, 10);  // 10 Hz
            
            lv_label_set_text(ui_Label1, "Polling...");
        }
    } else {
        // First connect - request vehicle scan
        ESP_LOGI(TAG, "Requesting vehicle scan...");
        lv_label_set_text(ui_Label1, "Scanning...");
        
        esp_err_t err = comm_link_request_scan(on_scan_complete);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "Failed to request scan: %s", esp_err_to_name(err));
            lv_label_set_text(ui_Label1, "Connect");
        }
    }
}
