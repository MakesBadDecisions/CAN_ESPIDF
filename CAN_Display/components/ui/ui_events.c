// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 8.3.11
// Project name: 4.3Gauge

#include "ui.h"
#include "comm_link.h"
#include "display_driver.h"
#include "gauge_engine.h"
#include "pid_store.h"
#include "data_logger.h"
#include "pid_types.h"
#include "imu_display.h"
#include "wifi_manager.h"
#include "system.h"
#include "device.h"
#include "tca9554.h"
#include "esp_log.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "ui_Screen1.h"
#include "ui_Screen2.h"
#include <stdio.h>
#include <string.h>

static const char *TAG = "ui_events";

// Forward declarations for static helpers
static void settings_screen_deferred_init(lv_timer_t *timer);
static void settings_screen_init_values(void);
static void on_brightness_changed(lv_event_t *e);
static void on_colorwheel_changed(lv_event_t *e);
static void populate_all_pid_dropdowns(void);
static void sys_info_timer_cb(lv_timer_t *timer);
static void on_sys_panel_delete(lv_event_t *e);

// Color wheel widget (created dynamically in ui_colorWhellPanel)
static lv_obj_t *s_colorwheel = NULL;
static lv_obj_t *s_colorwheel_label = NULL;

// System info panel (created dynamically in ui_systemPanel)
static lv_obj_t *s_sysinfo_label = NULL;
static lv_timer_t *s_sysinfo_timer = NULL;



// Default theme color: blue (RGB565 0x34DB ≈ RGB888 #3498DB)
// Must be a saturated color — white/gray (S≈0) makes the colorwheel arc invisible
#define THEME_COLOR_DEFAULT  0x34DB
#define THEME_NVS_NAMESPACE  "display"
#define THEME_NVS_KEY        "theme"

// Cached theme color for restoring after alert clears
static uint16_t s_cached_theme_color = THEME_COLOR_DEFAULT;

// ============================================================================
// Table-driven gauge widget mapping
//
// Each entry links a gauge_engine slot index to its LVGL widgets.
// To add more gauges: add rows here + create widgets in SquareLine.
// ============================================================================

typedef struct {
    lv_obj_t **gauge_panel;     // Parent panel (for IMU display attachment)
    lv_obj_t **pid_dropdown;    // PID selector
    lv_obj_t **unit_dropdown;   // Unit selector
    lv_obj_t **value_label;     // Numeric value text
} gauge_widget_t;

// Screen1 has 4 gauges -- just extend this array for more
static const gauge_widget_t s_gauge_widgets[] = {
    { &ui_gauge1, &ui_piddropdown1, &ui_unitdropdown1, &ui_gaugeText1 },
    { &ui_gauge2, &ui_piddropdown2, &ui_unitdropdown2, &ui_gaugeText2 },
    { &ui_gauge3, &ui_piddropdown3, &ui_unitdropdown3, &ui_gaugeText3 },
    { &ui_gauge4, &ui_piddropdown4, &ui_unitdropdown4, &ui_gaugeText4 },
};

#define NUM_GAUGE_WIDGETS (sizeof(s_gauge_widgets) / sizeof(s_gauge_widgets[0]))

// ============================================================================
// Timers
// ============================================================================

static lv_timer_t *s_gauge_timer = NULL;

// Scan timeout (10 seconds)
#define SCAN_TIMEOUT_MS  10000
static lv_timer_t *s_scan_timer = NULL;

// Track whether events have been wired (once per dropdown)
static bool s_events_registered = false;

// ============================================================================
// Connection Status Label (ui_statusLabel1 from SquareLine Studio)
// ============================================================================

static comm_link_state_t s_last_link_state = COMM_LINK_DISCONNECTED;
static uint8_t s_last_can_status = 0;
static lv_timer_t *s_status_timer = NULL;

/** Update the status label to show both UART link and CAN bus state */
static void update_status_label(void)
{
    if (!ui_statusLabel1) return;

    comm_link_state_t link = comm_link_get_state();
    uint8_t can = comm_link_get_can_status();

    if (link == s_last_link_state && can == s_last_can_status) return;
    s_last_link_state = link;
    s_last_can_status = can;

    // Build UART portion
    const char *uart_str;
    switch (link) {
        case COMM_LINK_CONNECTED:    uart_str = "OK";    break;
        case COMM_LINK_ERROR:        uart_str = "ERR";   break;
        default:                     uart_str = "OFF";   break;
    }

    // Build CAN portion
    const char *can_str;
    switch (can) {
        case 1:  can_str = "OK";  break;
        case 2:  can_str = "ERR"; break;
        default: can_str = "OFF"; break;
    }

    static char status_buf[32];
    snprintf(status_buf, sizeof(status_buf), "UART: %s | CAN: %s", uart_str, can_str);
    lv_label_set_text(ui_statusLabel1, status_buf);

    // Color: green only if both OK, red if any error, yellow if mixed
    if (link == COMM_LINK_CONNECTED && can == 1) {
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0x44FF44), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else if (link == COMM_LINK_ERROR || can == 2) {
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0xFF4444), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0xFFCC00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

static void status_timer_cb(lv_timer_t *timer)
{
    (void)timer;
    update_status_label();
}

// ============================================================================
// Scan Timeout Timer
// ============================================================================

static void scan_timeout_cb(lv_timer_t *timer)
{
    (void)timer;
    s_scan_timer = NULL;

    if (comm_link_get_scan_status() != SCAN_STATUS_COMPLETE) {
        ESP_LOGW(TAG, "Scan timed out after %d ms", SCAN_TIMEOUT_MS);
        lv_label_set_text(ui_Label1, "Scan");
        lv_label_set_text(ui_vehicleInfoLabel1, "Scan timeout");
    }
}

// ============================================================================
// Gauge Update Timer (10 Hz, LVGL task context)
// ============================================================================

static uint32_t s_stale_check_tick = 0;

static void gauge_update_cb(lv_timer_t *timer)
{
    (void)timer;

    // Check if poll list changed — repopulate PID dropdowns (LVGL-safe context)
    if (gauge_engine_pid_options_dirty()) {
        populate_all_pid_dropdowns();
    }

    // Skip update if no new data arrived (check stale every 1s regardless)
    bool new_data = gauge_engine_has_new_data();
    uint32_t now = lv_tick_get();
    bool stale_check = (now - s_stale_check_tick) >= 1000;

    if (!new_data && !stale_check) return;
    if (stale_check) s_stale_check_tick = now;

    // Let gauge_engine fetch values + convert + format strings
    gauge_engine_update();

    // Log a data row to SD card (if logging active)
    if (new_data) {
        logger_log_row();
    }

    // Push formatted strings to LVGL labels
    bool any_max = false;  // Track if any gauge hits ALERT_MAX for buzzer
    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        if (!g || g->pid_id == 0xFFFF) continue;

        // Virtual IMU — imu_display has its own timer, skip label update
        if (GAUGE_IS_VIRTUAL(g->pid_id)) continue;

        lv_obj_t *label = *(s_gauge_widgets[i].value_label);
        if (label) {
            lv_label_set_text(label, g->value_str);
            // Dim text when data is stale
            if (g->stale) {
                lv_obj_set_style_text_opa(label, LV_OPA_40, LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_obj_set_style_text_opa(label, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
            }
        }

        // ── Alert visual effects ──
        lv_obj_t *panel   = *(s_gauge_widgets[i].gauge_panel);
        lv_obj_t *pid_dd  = *(s_gauge_widgets[i].pid_dropdown);
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);

        if (g->alert_level == ALERT_MAX) {
            // MAX — flashing red borders + red text + buzzer
            bool flash_on = ((lv_tick_get() / 300) % 2) == 0;
            lv_color_t red  = lv_color_hex(0xFF2222);
            lv_color_t dark = lv_color_hex(0x1a1a2e);
            lv_color_t bc   = flash_on ? red : dark;
            if (panel)   lv_obj_set_style_border_color(panel,   bc,  LV_PART_MAIN | LV_STATE_DEFAULT);
            if (pid_dd)  lv_obj_set_style_border_color(pid_dd,  bc,  LV_PART_MAIN | LV_STATE_DEFAULT);
            if (unit_dd) lv_obj_set_style_border_color(unit_dd, bc,  LV_PART_MAIN | LV_STATE_DEFAULT);
            if (label)   lv_obj_set_style_text_color(label, red, LV_PART_MAIN | LV_STATE_DEFAULT);
            any_max = true;

        } else if (g->alert_level == ALERT_CRITICAL) {
            // CRITICAL — solid red borders + red text (no flash)
            lv_color_t red = lv_color_hex(0xFF2222);
            if (panel)   lv_obj_set_style_border_color(panel,   red, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (pid_dd)  lv_obj_set_style_border_color(pid_dd,  red, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (unit_dd) lv_obj_set_style_border_color(unit_dd, red, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (label)   lv_obj_set_style_text_color(label, red, LV_PART_MAIN | LV_STATE_DEFAULT);

        } else if (g->alert_level == ALERT_WARN) {
            // Yellow→red blended border based on position in warn zone
            uint8_t gr = 0xAA - (uint8_t)(g->alert_progress * (float)(0xAA - 0x22));
            lv_color_t wc = lv_color_make(0xFF, gr, 0x00);
            if (panel)   lv_obj_set_style_border_color(panel,   wc, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (pid_dd)  lv_obj_set_style_border_color(pid_dd,  wc, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (unit_dd) lv_obj_set_style_border_color(unit_dd, wc, LV_PART_MAIN | LV_STATE_DEFAULT);
            // Text stays theme color during warning
            lv_color_t tc; tc.full = s_cached_theme_color;
            if (label) lv_obj_set_style_text_color(label, tc, LV_PART_MAIN | LV_STATE_DEFAULT);

        } else {
            // Normal — restore theme colors
            lv_color_t tc; tc.full = s_cached_theme_color;
            if (panel)   lv_obj_set_style_border_color(panel,   tc, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (pid_dd)  lv_obj_set_style_border_color(pid_dd,  tc, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (unit_dd) lv_obj_set_style_border_color(unit_dd, tc, LV_PART_MAIN | LV_STATE_DEFAULT);
            if (label)   lv_obj_set_style_text_color(label, tc, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }

    // ── Buzzer control — sound on ALERT_MAX, silence otherwise ──
#if HAS_BUZZER
    {
        static bool s_buzzer_on = false;
        if (any_max && !s_buzzer_on) {
            tca9554_set_pin(EXIO_PIN_8, true);
            s_buzzer_on = true;
        } else if (!any_max && s_buzzer_on) {
            tca9554_set_pin(EXIO_PIN_8, false);
            s_buzzer_on = false;
        }
    }
#endif
}

// ============================================================================
// PID Dropdown Changed (any gauge)
// ============================================================================

static void on_pid_changed(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target(e);

    // Find which gauge slot this dropdown belongs to
    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        if (*(s_gauge_widgets[i].pid_dropdown) != dropdown) continue;

        uint16_t sel = lv_dropdown_get_selected(dropdown);

        // Check what was previously in this slot (for IMU detach)
        const gauge_slot_t *prev = gauge_engine_get_slot(i);
        bool was_imu = prev && prev->pid_id == VPID_IMU;

        gauge_engine_set_pid(i, sel);

        // Check if the new selection is IMU
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        bool is_imu = g && g->pid_id == VPID_IMU;

        // --- IMU attach / detach logic ---
        if (was_imu && !is_imu) {
            // Switching away from IMU — detach bubble, show value label
            imu_display_detach();
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_obj_clear_flag(label, LV_OBJ_FLAG_HIDDEN);
        }

        if (is_imu && !was_imu) {
            // Switching to IMU — enforce uniqueness (detach from other slot)
            for (int j = 0; j < (int)NUM_GAUGE_WIDGETS; j++) {
                if (j == i) continue;
                const gauge_slot_t *other = gauge_engine_get_slot(j);
                if (other && other->pid_id == VPID_IMU) {
                    gauge_engine_clear_slot(j);
                    lv_obj_t *other_label = *(s_gauge_widgets[j].value_label);
                    if (other_label) {
                        lv_obj_clear_flag(other_label, LV_OBJ_FLAG_HIDDEN);
                        lv_label_set_text(other_label, "---");
                    }
                    // Reset that slot's PID dropdown to "none" (first entry)
                    lv_obj_t *other_dd = *(s_gauge_widgets[j].pid_dropdown);
                    if (other_dd) lv_dropdown_set_selected(other_dd, 0);
                }
            }

            // Hide value label, attach IMU display to this gauge panel
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_obj_add_flag(label, LV_OBJ_FLAG_HIDDEN);

            lv_obj_t *panel = *(s_gauge_widgets[i].gauge_panel);
            imu_display_attach(panel);
        }

        // Refresh unit dropdown for this gauge
        static char unit_opts[GAUGE_UNIT_OPTS_LEN];
        gauge_engine_get_unit_options(i, unit_opts, sizeof(unit_opts));
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
        if (unit_dd) {
            lv_dropdown_set_options(unit_dd, unit_opts);
            lv_dropdown_set_selected(unit_dd, 0);
        }

        // Reset value display (for non-IMU slots)
        if (!is_imu) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        ESP_LOGI(TAG, "Gauge %d -> PID 0x%04X%s", i,
                 g ? g->pid_id : 0xFFFF, is_imu ? " (IMU)" : "");
        return;
    }
}

// ============================================================================
// Unit Dropdown Changed (any gauge)
// ============================================================================

static void on_unit_changed(lv_event_t *e)
{
    lv_obj_t *dropdown = lv_event_get_target(e);

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        if (*(s_gauge_widgets[i].unit_dropdown) != dropdown) continue;

        uint16_t sel = lv_dropdown_get_selected(dropdown);
        gauge_engine_set_unit(i, sel);

        // For IMU, also notify imu_display of mode change
        const gauge_slot_t *g = gauge_engine_get_slot(i);
        if (g && g->pid_id == VPID_IMU) {
            imu_display_set_mode((imu_display_mode_t)sel);
        } else if (g && g->value_valid) {
            // Immediately update the label if we have a value
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, g->value_str);
        }

        ESP_LOGI(TAG, "Gauge %d unit index -> %d", i, sel);
        return;
    }
}

// ============================================================================
// Register dropdown events for all gauge widgets (once)
// ============================================================================

static void register_gauge_events(void)
{
    if (s_events_registered) return;

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        lv_obj_t *pid_dd  = *(s_gauge_widgets[i].pid_dropdown);
        lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);

        if (pid_dd)  lv_obj_add_event_cb(pid_dd,  on_pid_changed,  LV_EVENT_VALUE_CHANGED, NULL);
        if (unit_dd) lv_obj_add_event_cb(unit_dd, on_unit_changed, LV_EVENT_VALUE_CHANGED, NULL);
    }

    s_events_registered = true;
    ESP_LOGI(TAG, "Registered events for %d gauge widgets", (int)NUM_GAUGE_WIDGETS);
}

// ============================================================================
// Populate all PID dropdowns with scan results
// ============================================================================

static void populate_all_pid_dropdowns(void)
{
    static char pid_opts[2048];
    int count = gauge_engine_build_pid_options(pid_opts, sizeof(pid_opts));
    if (count == 0) return;

    for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
        lv_obj_t *dd = *(s_gauge_widgets[i].pid_dropdown);
        if (dd) {
            lv_dropdown_set_options(dd, pid_opts);
        }
    }

    ESP_LOGI(TAG, "Populated %d gauge dropdowns with %d PIDs",
             (int)NUM_GAUGE_WIDGETS, count);
}

// ============================================================================
// Scan Complete Callback (called from rx_task, must lock LVGL)
// ============================================================================

static void on_scan_complete(scan_status_t status, const comm_vehicle_info_t *info)
{
    if (!display_lock(200)) {
        ESP_LOGW(TAG, "Could not acquire display lock for scan callback");
        return;
    }

    // Cancel scan timeout timer
    if (s_scan_timer) {
        lv_timer_del(s_scan_timer);
        s_scan_timer = NULL;
    }

    if (status == SCAN_STATUS_COMPLETE && info) {
        ESP_LOGI(TAG, "Scan complete! VIN: %.17s", info->vin);

        // Show VIN
        static char vin_text[32];
        snprintf(vin_text, sizeof(vin_text), "VIN: %.17s", info->vin);
        lv_label_set_text(ui_vehicleInfoLabel1, vin_text);
        lv_label_set_text(ui_Label1, "Scan");

        // Populate all gauge PID dropdowns
        populate_all_pid_dropdowns();

        // Wire up dropdown events (idempotent)
        register_gauge_events();

        // Restore saved gauge config (PID + unit per slot) from NVS
        int restored = gauge_engine_load_config();
        if (restored > 0) {
            // Sync dropdown selections to match restored slots
            int meta_count = comm_link_get_pid_meta_count();
            for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
                const gauge_slot_t *g = gauge_engine_get_slot(i);
                if (!g || g->pid_id == 0xFFFF) continue;

                // Handle virtual IMU PID restoration
                if (g->pid_id == VPID_IMU) {
                    // Set PID dropdown to IMU entry (index = meta_count)
                    lv_obj_t *pid_dd = *(s_gauge_widgets[i].pid_dropdown);
                    if (pid_dd) lv_dropdown_set_selected(pid_dd, meta_count);

                    // Set unit dropdown (G-Load / Tilt)
                    static char imu_unit_opts[GAUGE_UNIT_OPTS_LEN];
                    gauge_engine_get_unit_options(i, imu_unit_opts, sizeof(imu_unit_opts));
                    lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
                    if (unit_dd) {
                        lv_dropdown_set_options(unit_dd, imu_unit_opts);
                        lv_dropdown_set_selected(unit_dd, (int)g->display_unit);
                    }

                    // Hide value label and attach IMU display
                    lv_obj_t *label = *(s_gauge_widgets[i].value_label);
                    if (label) lv_obj_add_flag(label, LV_OBJ_FLAG_HIDDEN);

                    lv_obj_t *panel = *(s_gauge_widgets[i].gauge_panel);
                    imu_display_attach(panel);
                    imu_display_set_mode((imu_display_mode_t)g->display_unit);

                    ESP_LOGI(TAG, "Restored IMU in gauge slot %d", i);
                    continue;
                }

                // Find metadata index for this PID to set dropdown selection
                for (int m = 0; m < meta_count; m++) {
                    if (comm_link_get_meta_pid_id(m) == g->pid_id) {
                        lv_obj_t *pid_dd = *(s_gauge_widgets[i].pid_dropdown);
                        if (pid_dd) lv_dropdown_set_selected(pid_dd, m);
                        break;
                    }
                }

                // Refresh unit dropdown and select saved unit
                static char unit_opts[GAUGE_UNIT_OPTS_LEN];
                int n_units = gauge_engine_get_unit_options(i, unit_opts, sizeof(unit_opts));
                lv_obj_t *unit_dd = *(s_gauge_widgets[i].unit_dropdown);
                if (unit_dd && n_units > 0) {
                    lv_dropdown_set_options(unit_dd, unit_opts);
                    // Find which index corresponds to current display_unit
                    if (g->display_unit != g->base_unit) {
                        pid_unit_t alts[4];
                        int n_alts = pid_unit_get_alts(g->base_unit, alts, 4);
                        for (int u = 0; u < n_alts; u++) {
                            if (alts[u] == g->display_unit) {
                                lv_dropdown_set_selected(unit_dd, u + 1);
                                break;
                            }
                        }
                    }
                }
            }
            ESP_LOGI(TAG, "Restored %d gauge slot(s) from NVS", restored);
        } else {
            // No saved config -- auto-select first PID on gauge 0 as default
            gauge_engine_set_pid(0, 0);
            lv_obj_t *pid_dd = *(s_gauge_widgets[0].pid_dropdown);
            if (pid_dd) lv_dropdown_set_selected(pid_dd, 0);

            static char def_unit_opts[GAUGE_UNIT_OPTS_LEN];
            gauge_engine_get_unit_options(0, def_unit_opts, sizeof(def_unit_opts));
            lv_obj_t *unit_dd = *(s_gauge_widgets[0].unit_dropdown);
            if (unit_dd) {
                lv_dropdown_set_options(unit_dd, def_unit_opts);
                lv_dropdown_set_selected(unit_dd, 0);
            }
            ESP_LOGI(TAG, "No saved config, defaulted gauge 0 to first PID");
        }

    } else {
        ESP_LOGW(TAG, "Scan failed with status %d", status);
        lv_label_set_text(ui_Label1, "Scan");
    }

    display_unlock();
}

// ============================================================================
// Connect Button - Scan Vehicle
// ============================================================================

void connectCAN(lv_event_t * e)
{
    (void)e;

    if (comm_link_get_scan_status() == SCAN_STATUS_IN_PROGRESS) {
        ESP_LOGI(TAG, "Scan already in progress...");
        return;
    }

    ESP_LOGI(TAG, "Requesting vehicle scan...");
    lv_label_set_text(ui_Label1, "Scanning...");

    // Start scan timeout timer (one-shot)
    if (s_scan_timer) {
        lv_timer_del(s_scan_timer);
    }
    s_scan_timer = lv_timer_create(scan_timeout_cb, SCAN_TIMEOUT_MS, NULL);
    lv_timer_set_repeat_count(s_scan_timer, 1);

    esp_err_t err = comm_link_request_scan(on_scan_complete);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to request scan: %s", esp_err_to_name(err));
        lv_label_set_text(ui_Label1, "Scan");
    }
}

// ============================================================================
// Poll Button - Start/Stop Polling All Assigned Gauges
// ============================================================================

void pollCAN(lv_event_t * e)
{
    (void)e;

    if (gauge_engine_is_polling()) {
        // Stop logging first, then stop polling
        if (logger_get_state() == LOGGER_STATE_LOGGING) {
            logger_stop();
            ESP_LOGI(TAG, "Data logging stopped");
        }
        gauge_engine_stop_polling();
        lv_label_set_text(ui_Label2, "Poll");

        // Clear all gauge displays
        for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        if (s_gauge_timer) {
            lv_timer_del(s_gauge_timer);
            s_gauge_timer = NULL;
        }

        ESP_LOGI(TAG, "Polling stopped");
        return;
    }

    // Must scan first
    if (comm_link_get_pid_meta_count() == 0) {
        ESP_LOGW(TAG, "No PID metadata - scan vehicle first");
        return;
    }

    // Build poll list from pid_store selection (user's checked PIDs)
    // Falls back to gauge slot aggregation if no explicit selection exists
    uint16_t poll_pids[PID_STORE_MAX];
    int poll_count = pid_store_get_selected(poll_pids, PID_STORE_MAX);

    if (poll_count > 0) {
        // Send full selected list to CAN Interface
        uint8_t rate = pid_store_get_rate_hz();
        esp_err_t err = comm_link_set_poll_list(poll_pids, (uint8_t)poll_count, rate);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "Failed to set poll list: %s", esp_err_to_name(err));
            return;
        }

        // Register PID callback and mark polling active in gauge engine
        gauge_engine_start_polling(rate);

        ESP_LOGI(TAG, "Polling %d selected PIDs @ %d Hz", poll_count, rate);
    } else {
        // No pid_store selection — fall back to gauge-derived poll list
        esp_err_t err = gauge_engine_start_polling(10);
        if (err != ESP_OK) {
            ESP_LOGW(TAG, "No PIDs assigned to any gauge");
            return;
        }
        poll_count = gauge_engine_get_active_pid_count();
        ESP_LOGI(TAG, "Polling %d gauge PIDs @ 10 Hz (no PID selection)", poll_count);
    }

    // Start LVGL update timer (100ms = 10 Hz)
    if (!s_gauge_timer) {
        s_gauge_timer = lv_timer_create(gauge_update_cb, 100, NULL);
    }

    lv_label_set_text(ui_Label2, "Stop");

    // Auto-start data logger with full selected PID list
    if (logger_is_sd_mounted()) {
        uint16_t log_pids[PID_STORE_MAX];
        int log_count = pid_store_get_selected(log_pids, PID_STORE_MAX);

        // If no pid_store selection, fall back to gauge slots for logger
        if (log_count == 0) {
            for (int i = 0; i < GAUGE_MAX_SLOTS; i++) {
                const gauge_slot_t *g = gauge_engine_get_slot(i);
                if (!g || g->pid_id == 0xFFFF) continue;
                if (GAUGE_IS_VIRTUAL(g->pid_id)) continue;
                bool dup = false;
                for (int j = 0; j < log_count; j++) {
                    if (log_pids[j] == g->pid_id) { dup = true; break; }
                }
                if (!dup && log_count < PID_STORE_MAX) log_pids[log_count++] = g->pid_id;
            }
        }

        if (log_count > 0) {
            comm_vehicle_info_t vinfo;
            const char *vin = NULL;
            if (comm_link_get_vehicle_info(&vinfo)) {
                vin = vinfo.vin;
            }
            esp_err_t log_ret = logger_start(log_pids, log_count, vin);
            if (log_ret == ESP_OK) {
                ESP_LOGI(TAG, "Data logging started (%d channels)", log_count);
            } else {
                ESP_LOGW(TAG, "Data logging failed to start: %s", esp_err_to_name(log_ret));
            }
        }
    }
}

// ============================================================================
// Post-Init (called from main.c after ui_init + gauge_engine_init)
// Must be called with display lock held.
// ============================================================================

void ui_events_post_init(void)
{
    // Rename SquareLine-generated "Connect" button to "Scan"
    if (ui_Label1) {
        lv_label_set_text(ui_Label1, "Scan");
    }

    // Set initial state on SquareLine-created label
    if (ui_statusLabel1) {
        lv_label_set_text(ui_statusLabel1, "UART: OFF | CAN: OFF");
        lv_obj_set_style_text_color(ui_statusLabel1, lv_color_hex(0xFFCC00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    s_last_link_state = COMM_LINK_DISCONNECTED;
    s_last_can_status = 0;
    s_status_timer = lv_timer_create(status_timer_cb, 500, NULL);

    // Register our own event callback on the Settings button so that
    // settingsButton() gets called on tap. SquareLine Studio's generated
    // ui_event_settingsButton only does _ui_screen_change — it never calls
    // settingsButton(). This registration is SquareLine-safe because we
    // never edit the generated ui_Screen1.c file.
    if (ui_settingsButton) {
        lv_obj_add_event_cb(ui_settingsButton, settingsButton,
                            LV_EVENT_CLICKED, NULL);
        ESP_LOGI(TAG, "Settings button callback registered");
    }

    // IMU display initialized when user selects "IMU" in PID dropdown
    // (no longer tied to a fixed gyroPanel widget)

    // Show saved VIN from NVS (if available from previous session)
    comm_vehicle_info_t saved_info;
    if (comm_link_get_vehicle_info(&saved_info)) {
        static char vin_text[32];
        snprintf(vin_text, sizeof(vin_text), "VIN: %.17s", saved_info.vin);
        lv_label_set_text(ui_vehicleInfoLabel1, vin_text);
        ESP_LOGI(TAG, "Showing saved VIN: %.17s", saved_info.vin);
    }

    ESP_LOGI(TAG, "Status label and timer started");
}

// ============================================================================
// Settings Button — navigate to Screen2 (auto-stops polling)
// ============================================================================

void settingsButton(lv_event_t * e)
{
    (void)e;

    // Auto-stop polling when entering settings
    if (gauge_engine_is_polling()) {
        ESP_LOGI(TAG, "Stopping polling before entering settings...");

        // Stop logger first
        if (logger_get_state() == LOGGER_STATE_LOGGING) {
            logger_stop();
            ESP_LOGI(TAG, "Data logging stopped for settings");
        }

        gauge_engine_stop_polling();

        // Clear gauge displays
        for (int i = 0; i < (int)NUM_GAUGE_WIDGETS; i++) {
            lv_obj_t *label = *(s_gauge_widgets[i].value_label);
            if (label) lv_label_set_text(label, "---");
        }

        if (s_gauge_timer) {
            lv_timer_del(s_gauge_timer);
            s_gauge_timer = NULL;
        }

        // Update poll button text
        lv_label_set_text(ui_Label2, "Poll");
        ESP_LOGI(TAG, "Polling stopped");
    }

    // NOTE: SquareLine calls _ui_screen_change() AFTER this function returns,
    // which destroys and recreates Screen2. We must defer widget initialization
    // until after the screen transition completes.
    lv_timer_t *t = lv_timer_create(settings_screen_deferred_init, 200, NULL);
    lv_timer_set_repeat_count(t, 1);
}

// ============================================================================
// Settings Screen — deferred init (runs after screen transition completes)
// ============================================================================

static void settings_screen_deferred_init(lv_timer_t *timer)
{
    (void)timer;
    settings_screen_init_values();
}

static void settings_screen_init_values(void)
{
    // Set brightness slider to current value
    if (ui_brightnessSlider) {
        uint8_t bl = display_get_brightness();
        lv_slider_set_value(ui_brightnessSlider, bl, LV_ANIM_OFF);

        // Update label to match
        if (ui_brightnessLabel) {
            static char bl_text[8];
            snprintf(bl_text, sizeof(bl_text), "%d", bl);
            lv_label_set_text(ui_brightnessLabel, bl_text);
        }

        // Register brightness callback on the newly-created slider
        // (must re-register every time — Screen2 is destroyed/recreated on each visit)
        lv_obj_add_event_cb(ui_brightnessSlider, on_brightness_changed,
                            LV_EVENT_VALUE_CHANGED, NULL);
    }

    // Create color wheel inside ui_colorWhellPanel (recreated each visit)
    s_colorwheel = NULL;
    s_colorwheel_label = NULL;
    if (ui_colorWhellPanel) {
        // Get panel dimensions for sizing
        lv_coord_t pw = lv_obj_get_content_width(ui_colorWhellPanel);
        lv_coord_t ph = lv_obj_get_content_height(ui_colorWhellPanel);
        lv_coord_t cw_size = (pw < ph ? pw : ph) - 10;  // fit inside with margin
        if (cw_size < 60) cw_size = 60;

        s_colorwheel = lv_colorwheel_create(ui_colorWhellPanel, true);
        lv_obj_set_size(s_colorwheel, cw_size, cw_size);
        lv_obj_set_align(s_colorwheel, LV_ALIGN_CENTER);
        lv_colorwheel_set_mode_fixed(s_colorwheel, true);
        lv_obj_set_style_arc_width(s_colorwheel, 15, LV_PART_MAIN | LV_STATE_DEFAULT);

        // Hex label centered inside the wheel
        s_colorwheel_label = lv_label_create(s_colorwheel);
        lv_obj_set_width(s_colorwheel_label, LV_SIZE_CONTENT);
        lv_obj_set_height(s_colorwheel_label, LV_SIZE_CONTENT);
        lv_obj_set_align(s_colorwheel_label, LV_ALIGN_CENTER);

        // Restore saved color to the wheel position.
        // Guard: if saved color has near-zero saturation (white/gray), the
        // colorwheel arc becomes invisible (all hues at S=0 are white).
        // In that case, skip set_rgb and let the wheel use its built-in
        // default (red, H=0 S=100 V=100) which shows the full spectrum.
        uint16_t saved = ui_load_theme_color();
        lv_color_t saved_color;
        saved_color.full = saved;

        // Convert to HSV to check saturation
        lv_color_hsv_t hsv = lv_color_to_hsv(saved_color);
        if (hsv.s >= 20) {
            // Saturated enough — set the wheel to the saved color
            lv_colorwheel_set_rgb(s_colorwheel, saved_color);
        } else {
            // Too desaturated — use a visible default so the wheel shows colors
            saved_color.full = THEME_COLOR_DEFAULT;
            lv_colorwheel_set_rgb(s_colorwheel, saved_color);
            ESP_LOGW(TAG, "Saved color too desaturated (S=%d), using default", hsv.s);
        }

        // Set label text + color to match
        uint8_t r = (saved_color.ch.red   << 3) | (saved_color.ch.red   >> 2);
        uint8_t g = (saved_color.ch.green << 2) | (saved_color.ch.green >> 4);
        uint8_t b = (saved_color.ch.blue  << 3) | (saved_color.ch.blue  >> 2);
        static char hex_init[10];
        snprintf(hex_init, sizeof(hex_init), "#%02X%02X%02X", r, g, b);
        lv_label_set_text(s_colorwheel_label, hex_init);
        lv_obj_set_style_text_color(s_colorwheel_label, saved_color,
                                     LV_PART_MAIN | LV_STATE_DEFAULT);

        // Register callback (VALUE_CHANGED fires on every drag step)
        lv_obj_add_event_cb(s_colorwheel, on_colorwheel_changed,
                            LV_EVENT_VALUE_CHANGED, NULL);

        ESP_LOGI(TAG, "Color wheel created (size=%d, saved=0x%04X)", cw_size, saved);
    }

    // Apply theme color to Screen2 widgets (just recreated by screen transition)
    ui_apply_theme_color(ui_load_theme_color());

    // ---- System Info Panel ----
    // Create a multi-line label inside systemPanel, refreshed by timer
    s_sysinfo_label = NULL;
    if (s_sysinfo_timer) {
        lv_timer_del(s_sysinfo_timer);
        s_sysinfo_timer = NULL;
    }
    if (ui_systemPanel) {
        // Enable padding + flex column layout so the label fills the panel
        lv_obj_set_flex_flow(ui_systemPanel, LV_FLEX_FLOW_COLUMN);
        lv_obj_set_style_pad_all(ui_systemPanel, 6, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_pad_gap(ui_systemPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

        s_sysinfo_label = lv_label_create(ui_systemPanel);
        lv_obj_set_width(s_sysinfo_label, lv_pct(100));
        lv_obj_set_height(s_sysinfo_label, LV_SIZE_CONTENT);
        lv_obj_set_style_text_font(s_sysinfo_label, &lv_font_montserrat_10,
                                    LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_color(s_sysinfo_label,
                                     lv_color_hex(0xCCCCCC),
                                     LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_label_set_text(s_sysinfo_label, "Loading...");

        // Refresh every 1 second
        s_sysinfo_timer = lv_timer_create(sys_info_timer_cb, 1000, NULL);

        // Cleanup timer when systemPanel is destroyed (Screen2 transition)
        lv_obj_add_event_cb(ui_systemPanel, on_sys_panel_delete,
                            LV_EVENT_DELETE, NULL);

        // Fire immediately so panel isn't blank for 1 second
        sys_info_timer_cb(NULL);

        ESP_LOGI(TAG, "System info panel created");
    }

    ESP_LOGI(TAG, "Settings screen values initialized (brightness: %d%%)",
             display_get_brightness());
}

// ============================================================================
// System Info Panel — timer callback and cleanup
// ============================================================================

/**
 * @brief Format uptime from milliseconds into HH:MM:SS string
 */
static void format_uptime(uint32_t ms, char *buf, size_t len)
{
    uint32_t total_s = ms / 1000;
    uint32_t h = total_s / 3600;
    uint32_t m = (total_s % 3600) / 60;
    uint32_t s = total_s % 60;
    snprintf(buf, len, "%02lu:%02lu:%02lu", (unsigned long)h, (unsigned long)m, (unsigned long)s);
}

/**
 * @brief Refresh system info label with current data from both nodes
 */
static void sys_info_timer_cb(lv_timer_t *timer)
{
    (void)timer;
    if (!s_sysinfo_label) return;

    static char info_buf[320];
    char dsp_up[12], cif_up[12];

    // ---- Display Node data ----
    uint32_t dsp_heap   = sys_get_free_heap() / 1024;
    uint32_t dsp_min    = esp_get_minimum_free_heap_size() / 1024;
    uint32_t dsp_up_ms  = sys_time_ms();
    format_uptime(dsp_up_ms, dsp_up, sizeof(dsp_up));

    // SD / Logger
    logger_status_t log_st = logger_get_status();
    bool sd_ok = logger_is_sd_mounted();

    // ---- CAN Interface data (from heartbeat) ----
    comm_link_state_t link  = comm_link_get_state();
    uint8_t can_st          = comm_link_get_can_status();
    uint16_t cif_heap       = comm_link_get_remote_heap_kb();
    uint32_t cif_up_ms      = comm_link_get_remote_uptime_ms();
    uint8_t  cif_node_st    = comm_link_get_remote_node_state();
    format_uptime(cif_up_ms, cif_up, sizeof(cif_up));

    const comm_link_stats_t *stats = comm_link_get_stats();

    // CAN status string
    const char *can_str = (can_st == 1) ? "Running" :
                          (can_st == 2) ? "Error"   : "Off";

    // Link status string
    const char *link_str = (link == COMM_LINK_CONNECTED) ? "OK" :
                           (link == COMM_LINK_ERROR)     ? "Err" : "Down";

    // Node state string
    const char *node_str = (cif_node_st == 2) ? "Stream" :
                           (cif_node_st == 1) ? "Scan"   : "Idle";

    // SD status string
    const char *sd_str = sd_ok ? "Mounted" : "No SD";

    // Logger state
    const char *log_state_str;
    switch (log_st.state) {
        case LOGGER_STATE_LOGGING: log_state_str = "Logging"; break;
        case LOGGER_STATE_READY:   log_state_str = "Ready";   break;
        case LOGGER_STATE_ERROR:   log_state_str = "Error";   break;
        default:                   log_state_str = "Off";     break;
    }

    // ---- Format output ----
    int pos = 0;
    pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                    "-- Display Node --\n"
                    "Heap %luK  Min %luK\n"
                    "Up   %s\n",
                    (unsigned long)dsp_heap, (unsigned long)dsp_min, dsp_up);

    // SD + Logger line
    if (sd_ok && log_st.sd_total_bytes > 0) {
        float sd_free_gb = (float)log_st.sd_free_bytes / (1024.0f * 1024.0f * 1024.0f);
        pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                        "SD   %.1fG free%s  %s\n",
                        sd_free_gb,
                        log_st.sd_low_space ? " LOW!" : "",
                        log_state_str);
    } else {
        pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                        "SD   %s\n", sd_str);
    }

    if (log_st.state == LOGGER_STATE_LOGGING || log_st.rows_written > 0) {
        pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                        "Log  %s  %lu rows\n",
                        log_st.file_name[0] ? log_st.file_name : "--",
                        (unsigned long)log_st.rows_written);
    }

    // CAN Interface section
    pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                    "-- CAN Interface --\n");

    if (link == COMM_LINK_CONNECTED) {
        pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                        "Heap %uK  Up %s\n"
                        "CAN  %s  Node %s\n",
                        cif_heap, cif_up, can_str, node_str);
    } else {
        pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                        "UART %s\n", link_str);
    }

    // UART stats (always show)
    pos += snprintf(info_buf + pos, sizeof(info_buf) - pos,
                    "UART %s  RX %lu  TX %lu",
                    link_str,
                    (unsigned long)stats->rx_frames,
                    (unsigned long)stats->tx_frames);

    if (stats->rx_errors > 0 || stats->tx_errors > 0) {
        snprintf(info_buf + pos, sizeof(info_buf) - pos,
                 "  Err %lu",
                 (unsigned long)(stats->rx_errors + stats->tx_errors));
    }

    lv_label_set_text(s_sysinfo_label, info_buf);
}

/**
 * @brief Cleanup system info timer when systemPanel is destroyed
 */
static void on_sys_panel_delete(lv_event_t *e)
{
    (void)e;
    if (s_sysinfo_timer) {
        lv_timer_del(s_sysinfo_timer);
        s_sysinfo_timer = NULL;
    }
    s_sysinfo_label = NULL;
    ESP_LOGD(TAG, "System info panel cleaned up");
}

// ============================================================================
// Brightness Slider — apply brightness on value change
// ============================================================================

static void on_brightness_changed(lv_event_t *e)
{
    lv_obj_t *slider = lv_event_get_target(e);
    int32_t val = lv_slider_get_value(slider);
    if (val < 0) val = 0;
    if (val > 100) val = 100;

    display_set_brightness((uint8_t)val);

    // Update label
    if (ui_brightnessLabel) {
        static char bl_text[8];
        snprintf(bl_text, sizeof(bl_text), "%d", (int)val);
        lv_label_set_text(ui_brightnessLabel, bl_text);
    }
}

// ============================================================================
// Color Wheel — created inside ui_colorWhellPanel on Screen2
// ============================================================================

static void on_colorwheel_changed(lv_event_t *e)
{
    lv_obj_t *cw = lv_event_get_target(e);
    lv_color_t color = lv_colorwheel_get_rgb(cw);

    // Update hex label inside the wheel
    if (s_colorwheel_label) {
        static char hex_buf[10];
        // Convert RGB565 to approximate RGB888 for display
        uint8_t r = (color.ch.red   << 3) | (color.ch.red   >> 2);
        uint8_t g = (color.ch.green << 2) | (color.ch.green >> 4);
        uint8_t b = (color.ch.blue  << 3) | (color.ch.blue  >> 2);
        snprintf(hex_buf, sizeof(hex_buf), "#%02X%02X%02X", r, g, b);
        lv_label_set_text(s_colorwheel_label, hex_buf);
        lv_obj_set_style_text_color(s_colorwheel_label, color,
                                     LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    // Apply to all themed widgets on both screens
    ui_apply_theme_color(color.full);

    // Persist to NVS
    ui_save_theme_color(color.full);
}

// ============================================================================
// Theme Color — apply to all text and border widgets across both screens
// ============================================================================

void ui_apply_theme_color(uint16_t color_raw)
{
    s_cached_theme_color = color_raw;
    lv_color_t c;
    c.full = color_raw;

    // ---- Screen 1: Labels ----
    // Gauge value labels
    if (ui_gaugeText1) lv_obj_set_style_text_color(ui_gaugeText1, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_gaugeText2) lv_obj_set_style_text_color(ui_gaugeText2, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_gaugeText3) lv_obj_set_style_text_color(ui_gaugeText3, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_gaugeText4) lv_obj_set_style_text_color(ui_gaugeText4, c, LV_PART_MAIN | LV_STATE_DEFAULT);

    // Button labels
    if (ui_Label1) lv_obj_set_style_text_color(ui_Label1, c, LV_PART_MAIN | LV_STATE_DEFAULT);  // "Scan" label
    if (ui_Label2) lv_obj_set_style_text_color(ui_Label2, c, LV_PART_MAIN | LV_STATE_DEFAULT);  // "Poll" label
    if (ui_Label3) lv_obj_set_style_text_color(ui_Label3, c, LV_PART_MAIN | LV_STATE_DEFAULT);  // "Settings" label

    // Info labels
    if (ui_vehicleInfoLabel1) lv_obj_set_style_text_color(ui_vehicleInfoLabel1, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_statusLabel1)      lv_obj_set_style_text_color(ui_statusLabel1, c, LV_PART_MAIN | LV_STATE_DEFAULT);

    // ---- Screen 1: Button borders ----
    if (ui_connectCAN) {
        lv_obj_set_style_border_color(ui_connectCAN, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (ui_pollCAN1) {
        lv_obj_set_style_border_color(ui_pollCAN1, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (ui_settingsButton) {
        lv_obj_set_style_border_color(ui_settingsButton, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    // ---- Screen 1: Gauge panel borders ----
    if (ui_gauge1) lv_obj_set_style_border_color(ui_gauge1, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_gauge2) lv_obj_set_style_border_color(ui_gauge2, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_gauge3) lv_obj_set_style_border_color(ui_gauge3, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_gauge4) lv_obj_set_style_border_color(ui_gauge4, c, LV_PART_MAIN | LV_STATE_DEFAULT);

    // ---- Screen 1: Dropdown text + borders ----
    lv_obj_t *dropdowns[] = {
        ui_piddropdown1, ui_unitdropdown1,
        ui_piddropdown2, ui_unitdropdown2,
        ui_piddropdown3, ui_unitdropdown3,
        ui_piddropdown4, ui_unitdropdown4,
    };
    for (int i = 0; i < 8; i++) {
        if (dropdowns[i]) {
            lv_obj_set_style_text_color(dropdowns[i], c, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_border_color(dropdowns[i], c, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }

    // ---- Screen 2: Labels (only apply if Screen2 is active / widgets exist) ----
    if (ui_brightnessLabel) lv_obj_set_style_text_color(ui_brightnessLabel, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    if (ui_Label4) lv_obj_set_style_text_color(ui_Label4, c, LV_PART_MAIN | LV_STATE_DEFAULT);  // "Back" label
    if (ui_Label5) lv_obj_set_style_text_color(ui_Label5, c, LV_PART_MAIN | LV_STATE_DEFAULT);  // "WiFi Settings" label

    // ---- Screen 2: Button borders ----
    if (ui_backButton) {
        lv_obj_set_style_border_color(ui_backButton, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (ui_wifiAPstartButton1) {
        lv_obj_set_style_border_color(ui_wifiAPstartButton1, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    // ---- Screen 2: Slider border ----
    if (ui_brightnessSlider) {
        lv_obj_set_style_border_color(ui_brightnessSlider, c, LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    // ---- Screen 2: Panel borders ----
    if (ui_systemPanel) {
        lv_obj_set_style_border_color(ui_systemPanel, c, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_border_width(ui_systemPanel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_border_opa(ui_systemPanel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (ui_colorWhellPanel) {
        lv_obj_set_style_border_color(ui_colorWhellPanel, c, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_border_width(ui_colorWhellPanel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_border_opa(ui_colorWhellPanel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    ESP_LOGD(TAG, "Theme color applied: 0x%04X", color_raw);
}

// ============================================================================
// Theme Color — NVS persistence
// ============================================================================

void ui_save_theme_color(uint16_t color_raw)
{
    nvs_handle_t nvs;
    if (nvs_open(THEME_NVS_NAMESPACE, NVS_READWRITE, &nvs) == ESP_OK) {
        nvs_set_u16(nvs, THEME_NVS_KEY, color_raw);
        nvs_commit(nvs);
        nvs_close(nvs);
    }
}

uint16_t ui_load_theme_color(void)
{
    uint16_t color = THEME_COLOR_DEFAULT;
    nvs_handle_t nvs;
    if (nvs_open(THEME_NVS_NAMESPACE, NVS_READONLY, &nvs) == ESP_OK) {
        nvs_get_u16(nvs, THEME_NVS_KEY, &color);
        nvs_close(nvs);
    }
    return color;
}

// ============================================================================
// WiFi AP Start Button — start WiFi AP and show QR code
// ============================================================================

void wifiAPstart(lv_event_t * e)
{
    (void)e;
    ESP_LOGI(TAG, "WiFi AP start requested");

    if (wifi_manager_is_running()) {
        ESP_LOGI(TAG, "WiFi AP already running — stopping");
        wifi_manager_stop();
    } else {
        esp_err_t ret = wifi_manager_start();
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "wifi_manager_start failed: %s", esp_err_to_name(ret));
        }
    }
}
